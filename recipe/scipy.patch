From 70bb5d01822f84106694650f95125f7d3ed33036 Mon Sep 17 00:00:00 2001
From: Steve Schmerler <git@elcorto.com>
Date: Sun, 7 Jul 2024 21:47:24 +0200
Subject: [PATCH] MNT: fix numpy and scipy deprecations

For scipy 1.14 and numpy 2.0
---
 bin/matdyn2fqha.py      |  4 ++--
 src/pwtools/num.py      |  8 ++++----
 src/pwtools/pydos.py    |  3 +--
 src/pwtools/signal.py   | 39 ++++++++++++++++++++-------------------
 src/pwtools/thermo.py   |  6 +++---
 test/test_norm_int.py   |  4 ++--
 test/test_qha.py        |  4 ++--
 test/test_signal.py     |  2 +-
 test/test_trajectory.py |  2 +-
 9 files changed, 36 insertions(+), 36 deletions(-)

diff --git a/bin/matdyn2fqha.py b/bin/matdyn2fqha.py
index d8d91c59..4823e9a2 100755
--- a/bin/matdyn2fqha.py
+++ b/bin/matdyn2fqha.py
@@ -34,14 +34,14 @@
 
 import sys
 import numpy as np
-from scipy.integrate import simps
+from scipy.integrate import simpson as simps
 
 filename = sys.argv[1]
 arr = np.loadtxt(filename)
 freq = arr[:,0]
 dos = arr[:,1]
 
-integral = simps(dos, freq)
+integral = simps(dos, x=freq)
 
 natom = integral / 3.
 nstep = len(freq)
diff --git a/src/pwtools/num.py b/src/pwtools/num.py
index ea04ddb1..b5963110 100644
--- a/src/pwtools/num.py
+++ b/src/pwtools/num.py
@@ -3,7 +3,7 @@
 from math import sqrt, sin, cos, radians, pi
 import scipy.optimize as optimize
 from scipy.interpolate import bisplrep, bisplev, splev, splrep
-from scipy.integrate import simps
+from scipy.integrate import simpson as simps
 from pwtools import _flib
 import warnings
 
@@ -87,7 +87,7 @@ def norm_int(y, x, area=1.0, scale=True, func=simps):
         different scales.
     func : callable
         Function to do integration (like scipy.integrate.{simps,trapz,...}
-        Called as ``func(y,x)``. Default: simps
+        Called as ``func(y,x=x)``. Default: simps
 
     Returns
     -------
@@ -107,7 +107,7 @@ def norm_int(y, x, area=1.0, scale=True, func=simps):
         fx = fy = 1.0
         sx, sy = x, y
     # Area under unscaled y(x).
-    _area = func(sy, sx) * fx * fy
+    _area = func(sy, x=sx) * fx * fy
     return y * area / _area
 
 
@@ -1097,7 +1097,7 @@ def a2_to_an(self):
             a = np.unique(self.a2[:, colidx])
             axes.append(a)
             dims.append(len(a))
-        assert np.product(dims) == self.a2.shape[0]
+        assert np.prod(dims) == self.a2.shape[0]
         idx = itertools.product(*tuple(map(range, dims)))
         an = np.empty(dims, dtype=self.a2.dtype)
         # an[1,2,3] == an[(1,2,3)], need way to eliminate loop over index array
diff --git a/src/pwtools/pydos.py b/src/pwtools/pydos.py
index ee1ca960..a1375333 100644
--- a/src/pwtools/pydos.py
+++ b/src/pwtools/pydos.py
@@ -15,8 +15,7 @@
 import os, warnings
 import numpy as np
 from scipy.fftpack import fft
-from scipy.signal import convolve, gaussian
-from pwtools import constants, _flib, num
+from pwtools import _flib, num
 from pwtools.verbose import verbose
 from pwtools.signal import pad_zeros, welch, mirror
 
diff --git a/src/pwtools/signal.py b/src/pwtools/signal.py
index 3a3af11e..df2b4b07 100644
--- a/src/pwtools/signal.py
+++ b/src/pwtools/signal.py
@@ -6,8 +6,7 @@
 from itertools import product
 import numpy as np
 from scipy.fftpack import fft, ifft
-from scipy.signal import fftconvolve, gaussian, kaiserord, firwin, lfilter, freqz
-from scipy.integrate import trapz
+from scipy.signal import fftconvolve, kaiserord, firwin, lfilter, freqz
 from pwtools import _flib, num
 
 
@@ -300,7 +299,7 @@ def pad_zeros(arr, axis=0, where='end', nadd=None, upto=None, tonext=None,
 
 def welch(M, sym=1):
     """Welch window. Function skeleton shamelessly stolen from
-    scipy.signal.bartlett() and others."""
+    scipy.signal.windows.bartlett() and others."""
     if M < 1:
         return np.array([])
     if M == 1:
@@ -316,7 +315,7 @@ def welch(M, sym=1):
 
 def lorentz(M, std=1.0, sym=True):
     r"""Lorentz window (same as Cauchy function). Function skeleton stolen from
-    scipy.signal.gaussian().
+    scipy.signal.windows.gaussian().
 
     The Lorentz function is
 
@@ -621,35 +620,37 @@ def smooth(data, kern, axis=0, edge='m', norm=True):
 
     Examples
     --------
-    >>> from pwtools.signal import welch
+    >>> from pwtools.signal import welch, smooth
     >>> from numpy.random import rand
+    >>> from scipy.signal.windows import hann, gaussian
+    >>> from scipy.signal import convolve
     >>> x = linspace(0,2*pi,500); a=cos(x)+rand(500)
     >>> plot(a, color='0.7')
-    >>> k=scipy.signal.hann(21)
-    >>> plot(signal.smooth(a,k), 'r', label='hann')
-    >>> k=scipy.signal.gaussian(21, 3)
-    >>> plot(signal.smooth(a,k), 'g', label='gauss')
+    >>> k=hann(21)
+    >>> plot(smooth(a,k), 'r', label='hann')
+    >>> k=gaussian(21, 3)
+    >>> plot(smooth(a,k), 'g', label='gauss')
     >>> k=welch(21)
-    >>> plot(signal.smooth(a,k), 'y', label='welch')
+    >>> plot(smooth(a,k), 'y', label='welch')
     >>> legend()
     >>> # odd kernel [0,1,0] reproduces data exactly, i.e. convolution with
     >>> # delta peak
     >>> figure(); title('smooth with delta [0,1,0]')
     >>> x=linspace(0,2*pi,15); k=scipy.signal.hann(3)
     >>> plot(cos(x))
-    >>> plot(signal.smooth(cos(x),k), 'r')
+    >>> plot(smooth(cos(x),k), 'r')
     >>> legend()
     >>> # edge effects with normal convolution
     >>> figure(); title('edge effects')
-    >>> x=rand(20)+10; k=scipy.signal.hann(11);
-    >>> plot(x); plot(signal.smooth(x,k),label="smooth");
-    >>> plot(scipy.signal.convolve(x,k/k.sum(),'same'), label='convolve')
+    >>> x=rand(20)+10; k=hann(11);
+    >>> plot(x); plot(smooth(x,k),label="smooth");
+    >>> plot(convolve(x,k/k.sum(),'same'), label='convolve')
     >>> legend()
     >>> # edge effect methods
     >>> figure(); title('edge effect methods')
-    >>> x=rand(20)+10; k=scipy.signal.hann(20);
-    >>> plot(x); plot(signal.smooth(x,k,edge='m'),label="edge='m'");
-    >>> plot(signal.smooth(x,k,edge='c'),label="edge='c'");
+    >>> x=rand(20)+10; k=hann(20);
+    >>> plot(x); plot(smooth(x,k,edge='m'),label="edge='m'");
+    >>> plot(smooth(x,k,edge='c'),label="edge='c'");
     >>> legend()
     >>> # smooth a trajectory of atomic coordinates
     >>> figure(); title('trajectory')
@@ -657,8 +658,8 @@ def smooth(data, kern, axis=0, edge='m', norm=True):
     >>> a = rand(500,2,3) # (nstep, natoms, 3)
     >>> a[:,0,:] += cos(x)[:,None]
     >>> a[:,1,:] += sin(x)[:,None]
-    >>> k=scipy.signal.hann(21)[:,None,None]
-    >>> y = signal.smooth(a,k)
+    >>> k=hann(21)[:,None,None]
+    >>> y = smooth(a,k)
     >>> plot(a[:,0,0], color='0.7'); plot(y[:,0,0],'b',
     ...                                   label='atom1 x')
     >>> plot(a[:,1,0], color='0.7'); plot(y[:,1,0],'r',
diff --git a/src/pwtools/thermo.py b/src/pwtools/thermo.py
index f625ba97..61a544c8 100644
--- a/src/pwtools/thermo.py
+++ b/src/pwtools/thermo.py
@@ -3,7 +3,7 @@
 import warnings
 
 import numpy as np
-from scipy.integrate import simps, trapz
+from scipy.integrate import trapezoid as trapz
 from pwtools.constants import kb, hplanck, R, pi, c0, Ry_to_J, eV,\
     eV_by_Ang3_to_GPa
 from pwtools.verbose import verbose
@@ -48,7 +48,7 @@ def __init__(self, freq, dos, T=None, temp=None, skipfreq=False,
             If not None, then re-normalize the area int(freq) dos to `dosarea`,
             after `skipfreq` was applied if used.
         integrator : callable
-            Function which integrates x-y data. Called as ``integrator(y,x)``,
+            Function which integrates x-y data. Called as ``integrator(y,x=x)``,
             like ``scipy.integrate.{trapz,simps}``. Usually, `trapz` is
             numerically more stable for weird DOS data and accurate enough if
             the frequency axis resolution is good.
@@ -158,7 +158,7 @@ def _norm_int(self, y, x, area):
         fy = np.abs(y).max()
         sx = x / fx
         sy = y / fy
-        _area = self.integrator(sy, sx) * fx * fy
+        _area = self.integrator(sy, x=sx) * fx * fy
         return y*area/_area
 
     def _printwarn(self, msg):
diff --git a/test/test_norm_int.py b/test/test_norm_int.py
index b3ebd3dd..61b8c78b 100644
--- a/test/test_norm_int.py
+++ b/test/test_norm_int.py
@@ -1,5 +1,5 @@
 import numpy as np
-from scipy.integrate import simps
+from scipy.integrate import simpson as simps
 from pwtools.num import norm_int
 
 def test_norm_int():
@@ -9,4 +9,4 @@ def test_norm_int():
 
     for scale in [True, False]:
         yy = norm_int(y, x, area=10.0, scale=scale)
-        assert np.allclose(simps(yy,x), 10.0)
+        assert np.allclose(simps(yy,x=x), 10.0)
diff --git a/test/test_qha.py b/test/test_qha.py
index ed2371c5..b6227c71 100644
--- a/test/test_qha.py
+++ b/test/test_qha.py
@@ -7,7 +7,7 @@
 import numpy as np
 from numpy.testing import assert_array_almost_equal as aaae
 
-from scipy.integrate import simps, trapz
+from scipy.integrate import simpson as simps
 from pwtools.thermo import HarmonicThermo
 from pwtools import common
 from pwtools.constants import Ry_to_J, eV, Ry, kb
@@ -91,4 +91,4 @@ def test_qha():
     area = np.random.rand()*10
     ha = HarmonicThermo(pdos[:,0], pdos[:,1], skipfreq=True, dosarea=area,
                         integrator=simps)
-    assert np.allclose(simps(ha.dos, ha.f), area)
+    assert np.allclose(simps(ha.dos, x=ha.f), area)
diff --git a/test/test_signal.py b/test/test_signal.py
index 89971794..3c632b89 100644
--- a/test/test_signal.py
+++ b/test/test_signal.py
@@ -1,5 +1,5 @@
 import numpy as np
-from scipy.signal import gaussian
+from scipy.signal.windows import gaussian
 from pwtools.signal import gauss, find_peaks, smooth, fft_1d_loop, ezfft
 from pwtools import signal
 from scipy.fftpack import fft
diff --git a/test/test_trajectory.py b/test/test_trajectory.py
index 2f74992b..b9eaaeb9 100644
--- a/test/test_trajectory.py
+++ b/test/test_trajectory.py
@@ -4,7 +4,7 @@
 import copy
 
 import numpy as np
-from scipy.signal import hann
+from scipy.signal.windows import hann
 
 from pwtools.crys import Trajectory, Structure
 from pwtools import crys, constants
